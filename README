# 🌟 **Operating Systems Scheduler with Buddy Memory Allocation** 🌟  

Welcome to the **Operating Systems Scheduler** project! 🚀 This repository showcases an advanced simulation of operating system functionalities, combining efficient CPU scheduling algorithms with dynamic memory management using the buddy system. Dive in to explore a comprehensive system design that emphasizes performance, accuracy, and modularity.  

---

## 🎉 **Key Features Overview** 🎉  

### 🔄 **Process Scheduling**  
Experience the power of scheduling with three industry-standard algorithms:  

- **Non-preemptive Highest Priority First (HPF)** 🚦: Prioritize critical tasks.  
- **Shortest Remaining Time Next (SRTN)** ⏳: Minimize task completion time.  
- **Round Robin (RR)** 🔄: Ensure fair CPU time distribution.  

Each scheduling algorithm is tailored to manage processes efficiently, track their states, and log detailed execution timelines.  

---  

### 🧠 **Buddy Memory Allocation**  
Seamlessly allocate and deallocate memory with our buddy system:  

- **Dynamic memory blocks**: Allocate memory for processes as they enter the system.  
- **Efficient reuse**: Free and recycle memory upon process termination.  
- **Custom memory logging**: Track allocations with precision.  

Example output:  
```txt  
#At time x allocated y bytes for process z from i to j  
At time 1 allocated 200 bytes for process 1 from 0 to 255  
At time 3 allocated 170 bytes for process 2 from 256 to 511  
```  

---  

### 📊 **Performance Metrics**  
Gain insights into your system’s efficiency:  

- **CPU Utilization**: Measure processor activity.  
- **Average Weighted Turnaround Time (WTA)** 📈.  
- **Average Waiting Time** ⌛.  
- **Standard Deviation of WTA** 📊.  

Logs are auto-generated to provide clear, standardized outputs for analysis.  

---  

### 🛠️ **Robust Simulation**  
This project leverages **Inter-Process Communication (IPC)** to simulate real-world OS functionality:  

- **Process Management**: Create, manage, and track processes.  
- **Clock Emulation**: Synchronize actions with a simulated integer time clock.  
- **State Management**: Transition processes between Running, Ready, and Blocked states seamlessly.  

---  

## 🚀 **Getting Started**  

### **Prerequisites**  
Ensure your environment includes:  

- **Linux OS** 🐧.  
- **gcc Compiler**: For building the project.  
- **Makefiles**: Optional but recommended for efficient builds.  

---  

### **Installation**  

1. **Clone the repository**:  
   ```bash  
   https://github.com/omarhashem80/OS-Scheduler.git 
   cd OS-Scheduler 
   ```  

2. **Compile the project**:  
   ```bash  
   make  
   ```  

3. **Run the simulation**:  
   ```bash  
   make run  
   ```  

---  

## 🖥️ **Project Structure**  

- **process_generator.c**: Handles process generation and IPC setup.  
- **scheduler.c**: Implements scheduling algorithms and manages memory allocation.  
- **clk.c**: Simulates an integer clock for process scheduling.  
- **process.c**: Simulates process behavior and state transitions.  

### Input: `processes.txt`  
Defines process attributes, including arrival time, runtime, priority, and memory size.  

Example:  
```txt  
#id	arrival	runtime	priority	memsize  
1	1	6	5	200  
2	3	3	3	170  
```  

---  

## 👥 **Contributors**  

We appreciate the dedication and hard work of our team:  

- **[Omar Hashem](https://github.com/omarhashem80)** – member 💻
- **[Abdelrahman Mohamed Abdelaty](https://github.com/Abdelrahman-Mohamed-Abdelaty)** – member 💻
- **[Youssef Bahy](https://github.com/Youssef-Bahy-Youssef)** – member 💻
- **[Ali Afifi](https://github.com/Ali-Afifi-Hussain)** – member 💻

---  

## 🌟 **Thank You!**  

Thank you for exploring our OS Scheduler project! Your feedback, contributions, and ideas are always welcome. Together, let’s push the boundaries of operating system simulations! 🎉  

---  
